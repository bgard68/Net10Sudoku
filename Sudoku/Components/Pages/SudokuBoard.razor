@page "/"
@using Sudoku.Application.Services
@using Sudoku.Application.Interfaces
@using Sudoku.Domain
@rendermode InteractiveServer
@inject SudokuService Sudoku
@inject ThemeService ThemeService
@implements IDisposable

<PageTitle>Sudoku Game</PageTitle>

<div class="sudoku-root @(ThemeService.IsDarkMode ? "dark-mode" : "")" @onmouseup="OnMouseUp">
    <div class="toolbar">
        <button class="btn diff easy" @onclick="(() => New(Difficulty.Easy))">Easy</button>
        <button class="btn diff med" @onclick="(() => New(Difficulty.Medium))">Medium</button>
        <button class="btn diff hard" @onclick="(() => New(Difficulty.Hard))">Hard</button>
        <span class="spacer"></span>
        <button class="btn action validate" @onclick="Validate">Validate</button>
        <button class="btn action hint" @onclick="ApplyHint">Hint</button>
        <button class="btn action solve" @onclick="Solve">Solve</button>
        <button class="btn action clear-all" @onclick="ClearAll">Clear All</button>
    </div>

    <div class="board @(isSolved ? "celebration" : "")" @key="boardKey" @onmouseleave="EndDrag">
        @for (var row = 0; row < 9; row++)
        {
            var r = row;
            <div class="srow">
                @for (var col = 0; col < 9; col++)
                {
                    var c = col;
                    var cellClasses = GetCellClasses(r, c);
                    var cellValue = Sudoku.Current.Cells[r, c].Value;
                    <div class="@cellClasses"
                         tabindex="0"
                         role="button"
                         aria-selected="@IsSelected(r,c)"
                         @onclick="@(()=>HandleClick(r,c))"
                         @onpointerdown="@(()=>HandlePointerDown(r,c))"
                         @onpointerenter="@(()=>HandlePointerEnter(r,c))"
                         @onfocus="@(()=>HandleFocus(r,c))"
                         @onkeyup="@(e=>HandleKeyUp(e,r,c))">
                    @if (cellValue is int val)
                    {
                        <span>@val</span>
                    }
                    </div>
                }
            </div>
        }
        @if (Sudoku.Selected is Position sel)
        {
            var blockRow = (sel.Row / 3) * 3;
            var blockCol = (sel.Col / 3) * 3;
            var topPx = blockRow * 52 + blockRow; // add 1px per preceding row border
            var leftPx = blockCol * 52 + blockCol;
            <div class="block-overlay" style="top:@topPx}px;left:@leftPx}px;"></div>
        }
    </div>

    @if (isSolved)
    {
        <div class="scrolling-text-container">
            <div class="scrolling-text">CONGRATULATIONS! CONGRATULATIONS! CONGRATULATIONS! CONGRATULATIONS! </div>
        </div>
    }

    <div class="numpad">
        @for (int n = 1; n <= 9; n++)
        {
            var num = n; // Local copy
            var done = IsNumberFullyPlacedAndValid(num);
            if (done)
            {
                <button class="btn num complete" disabled title="Completed">&#10003;</button>
            }
            else
            {
                <button class="btn num" @onclick="(()=>Place(num))" title="Place @num">@num</button>
            }
        }
        <button class="btn clear" @onclick="Clear">Clear</button>
    </div>

    <div class="status">Selected: @(Sudoku.Selected is Position sp ? $"({sp.Row+1},{sp.Col+1})" : "none")</div>

    @if (message is not null && !isSolved)
    {
        <div class="message">@message</div>
    }

    @if (isSolved)
    {
        <div class="starbursts-container">
            @* Generate 25 firework starbursts at random positions *@
            @for (int i = 0; i < 25; i++)
            {
                var x = Random.Shared.Next(10, 90);
                var y = Random.Shared.Next(15, 85);
                var color = GetRandomColor();
                var delay = Random.Shared.Next(0, 2500);
                
                <div class="starburst" 
                     style="left: @(x)%; 
                            top: @(y)%; 
                            animation-delay: @(delay)ms;">
                    
                    @* Create 20 particles radiating outward *@
                    @for (int p = 0; p < 20; p++)
                    {
                        var angle = p * 18.0; // 360/20 = 18 degrees
                        var distance = Random.Shared.Next(50, 90);
                        var particleDelay = delay + Random.Shared.Next(0, 200);
                        
                        <div class="particle" 
                             style="--angle: @(angle)deg; 
                                    --distance: @(distance)px;
                                    background: @color;
                                    animation-delay: @(particleDelay)ms;"></div>
                    }
                </div>
            }
        </div>
    }
</div>

@code {
    [Inject] public ISudokuValidator Validator { get; set; } = default!;

    private bool isDragging;
    private string? message;
    private int boardKey = 0;
    private bool isSolved = false;

    protected override void OnInitialized()
    {
        Sudoku.New(Difficulty.Easy);
        Sudoku.ClearSelection();
        boardKey++;
        ThemeService.OnThemeChanged += OnThemeChanged;
    }

    private void OnThemeChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        ThemeService.OnThemeChanged -= OnThemeChanged;
    }

    void New(Difficulty d)
    {
        Sudoku.New(d);
        Sudoku.ClearSelection();
        message = $"New {d} puzzle generated.";
        isSolved = false;
        boardKey++;
    }

    void HandleClick(int r, int c)
    {
        if (r < 0 || r >= 9 || c < 0 || c >= 9) return;
        Sudoku.Select(r, c);
    }

    void HandleFocus(int r, int c)
    {
        if (r < 0 || r >= 9 || c < 0 || c >= 9) return;
        Sudoku.Select(r, c);
    }

    void HandlePointerDown(int r, int c)
    {
        if (r < 0 || r >= 9 || c < 0 || c >= 9) return;
        isDragging = true;
        Sudoku.Select(r, c);
    }

    void HandlePointerEnter(int r, int c)
    {
        if (!isDragging || r < 0 || r >= 9 || c < 0 || c >= 9) return;
        Sudoku.Select(r, c);
    }

    void Place(int n)
    {
        Sudoku.Place(n);
        CheckIfSolved();
    }

    void Clear()
    {
        Sudoku.Clear();
        isSolved = false;
    }

    void ClearAll()
    {
        Sudoku.ClearAll();
        message = "All user entries cleared.";
        isSolved = false;
    }

    void Validate()
    {
        bool isValid = Sudoku.Validate();
        if (isValid && Sudoku.IsComplete())
        {
            isSolved = true;
            message = null;
        }
        else
        {
            message = isValid ? "Board is valid so far." : "There are conflicts.";
        }
    }

    void CheckIfSolved()
    {
        if (Sudoku.IsComplete())
        {
            isSolved = true;
            message = null;
        }
    }

    void ApplyHint()
    {
        if (Sudoku.Selected is null)
        {
            message = "Please select a cell first to get a hint.";
            return;
        }

        var hint = Sudoku.GetHintForSelectedCell();
        
        if (hint is null)
        {
            var cell = Sudoku.Current.Cells[Sudoku.Selected.Value.Row, Sudoku.Selected.Value.Col];
            if (cell.IsGiven)
            {
                message = "Cannot provide hint for given cells.";
            }
            else
            {
                message = "Unable to determine hint for this cell.";
            }
            return;
        }

        Sudoku.ApplyHintForSelectedCell();
        message = $"Hint: placed {hint.Value.value} in the selected cell";
        
        CheckIfSolved();
    }

    void Solve()
    {
        bool solved = Sudoku.Solve();
        if (solved)
        {
            isSolved = true;
            message = null;
        }
        else
        {
            message = "No solution.";
        }
    }

    void EndDrag()
    {
        isDragging = false;
    }

    void OnMouseUp(MouseEventArgs _)
    {
        isDragging = false;
    }

    void HandleKeyUp(KeyboardEventArgs e, int r, int c)
    {
        if (e.Key is null || r < 0 || r >= 9 || c < 0 || c >= 9) return;
        
        if (int.TryParse(e.Key, out var n) && n is >= 1 and <= 9)
        {
            Sudoku.Select(r, c);
            Sudoku.Place(n);
            CheckIfSolved();
        }
        else if (e.Key == "Backspace" || e.Key == "Delete")
        {
            Sudoku.Select(r, c);
            Sudoku.Clear();
        }
    }

    bool IsSelected(int r, int c)
    {
        if (r < 0 || r >= 9 || c < 0 || c >= 9) return false;
        return Sudoku.Selected?.Row == r && Sudoku.Selected?.Col == c;
    }

    string GetCellClasses(int r, int c)
    {
        if (r < 0 || r >= 9 || c < 0 || c >= 9) return "cell";
        var cell = Sudoku.Current.Cells[r, c];
        bool isSelected = IsSelected(r, c);
        bool sameRow = Sudoku.Selected?.Row == r;
        bool sameCol = Sudoku.Selected?.Col == c;
        bool hasConflict = Sudoku.HasConflict(r, c);
        bool sameBlock = false;
        bool sameValue = false;
        if (Sudoku.Selected is Position sp)
        {
            sameBlock = (r / 3 == sp.Row / 3) && (c / 3 == sp.Col / 3);
            var selectedVal = Sudoku.Current.Cells[sp.Row, sp.Col].Value;
            if (selectedVal is int sv && cell.Value is int cv && sv == cv)
            {
                sameValue = true;
            }
        }
        string borderClasses = (r % 3 == 0 ? " top3" : "") + (c % 3 == 0 ? " left3" : "") + (r == 8 ? " bottom3" : "") + (c == 8 ? " right3" : "");
        return $"cell{(cell.IsGiven ? " given" : "")}{(isSelected ? " selected" : "")}{(sameRow ? " rowhl" : "")}{(sameCol ? " colhl" : "")}{(sameBlock ? " blockhl" : "")}{(sameValue ? " valhl" : "")}{(hasConflict ? " conflict" : "")}{borderClasses}";
    }

    string GetRandomColor()
    {
        var colors = new[] { "#ff0080", "#00ffff", "#ffff00", "#ff00ff", "#00ff00", "#ff8800", "#0088ff", "#ff0000", "#8800ff", "#ff69b4", "#00fa9a", "#ffd700", "#ff1493", "#7fff00" };
        return colors[Random.Shared.Next(colors.Length)];
    }

    bool IsNumberFullyPlacedAndValid(int n)
    {
        // must appear exactly once per row, column, and 3x3 block
        // board is 9x9; treat empty cells (null) as not placed
        // Return false immediately on any rule violation
        for (int r = 0; r < 9; r++)
        {
            int countRow = 0;
            for (int c = 0; c < 9; c++)
            {
                var v = Sudoku.Current.Cells[r, c].Value;
                if (v is int vInt && vInt == n) countRow++;
            }
            if (countRow != 1) return false;
        }
        for (int c = 0; c < 9; c++)
        {
            int countCol = 0;
            for (int r = 0; r < 9; r++)
            {
                var v = Sudoku.Current.Cells[r, c].Value;
                if (v is int vInt && vInt == n) countCol++;
            }
            if (countCol != 1) return false;
        }
        for (int br = 0; br < 3; br++)
        {
            for (int bc = 0; bc < 3; bc++)
            {
                int countBlock = 0;
                for (int r = br * 3; r < br * 3 + 3; r++)
                {
                    for (int c = bc * 3; c < bc * 3 + 3; c++)
                    {
                        var v = Sudoku.Current.Cells[r, c].Value;
                        if (v is int vInt && vInt == n) countBlock++;
                    }
                }
                if (countBlock != 1) return false;
            }
        }
        // Optional: ensure the overall board state is valid for this number (no conflicts)
        // We rely on Sudoku.HasConflict, but that checks per-cell; here we ensure none of the placed n values conflict
        for (int r = 0; r < 9; r++)
        for (int c = 0; c < 9; c++)
        {
            var v = Sudoku.Current.Cells[r, c].Value;
            if (v is int vInt && vInt == n)
            {
                if (Sudoku.HasConflict(r, c)) return false;
            }
        }
        return true;
    }
}
